package searchHotels

import com.ftn.sbnz.backward.model.models.hotel.*;
import java.time.LocalDate;
import java.util.Date;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Collection;
import java.time.ZoneId;
import java.text.SimpleDateFormat
import java.util.ArrayList
import java.util.HashSet
import java.util.Comparator
import java.util.stream.Collectors;

rule "Filter Hotels"
lock-on-active
when
    $searchParams: SearchHotelsParams()
    $hotel: Hotel(
        name.toLowerCase().contains($searchParams.name.toLowerCase()),
        city.toLowerCase().contains($searchParams.destination.toLowerCase()) ||
        country.toLowerCase().contains($searchParams.destination.toLowerCase()),
        rating >= $searchParams.reviewScore,
        stars memberOf $searchParams.starRating || $searchParams.starRating.size() == 0,
        distanceFromCenter >= $searchParams.distanceStart,
        distanceFromCenter <= $searchParams.distanceEnd
    )
then
    List<String> f = $hotel.getFacilities().stream().map(HotelFacility::getFacility).collect(Collectors.toList());
    if(f.containsAll($searchParams.getFacilities())) {
        insert(new CalculateHotelPrice($hotel, $searchParams));
    }
end

rule "Calculate Hotel Price"
no-loop
when
    $calculateHotelPrice: CalculateHotelPrice(
        $hotel: hotel,
        $searchParams: searchHotelsParams
    )
then
    // CALCULATE PRICE
    double numOfNights = calculateNumberOfNights($searchParams.getStartDate(), $searchParams.getEndDate());
    double basicPrice = 10.0 * $hotel.getStars() * numOfNights;
    double mealPrice = ($searchParams.getNumAdults() + $searchParams.getNumChildren()) * HotelUtils.getPrice($searchParams.getMeals()) * numOfNights * $hotel.getStars();
    double totalPrice = basicPrice + mealPrice;

    // LAST MINUTE DISCOUNT
    int daysBeforeStay = calculateNumberOfNights(new Date(), $searchParams.getStartDate());
    double lastMinuteDiscount = holidayDiscount(daysBeforeStay, isHolidayPeriod($searchParams.getStartDate()));
    if (lastMinuteDiscount > 0.0) {
        totalPrice -= totalPrice * (lastMinuteDiscount / 100);
    }

    if (totalPrice >= $searchParams.getPriceRangeStart() && $searchParams.getPriceRangeEnd() >= totalPrice) {
        modify($searchParams){addHotel(new HotelResponse($hotel, totalPrice));}
    }
end

rule "Available room"
when
    $checkRoomAvailability: CheckRoomAvailability($hotel: hotel, $params: reserveHotelParams)
    $room: HotelRoom($roomOccupancies: roomOccupancies, $hotel.getId() == hotelId, numberOfAdults >= $params.getNumberOfAdults(), numberOfChildren >= $params.getNumberOfChildren())
    not(RoomOccupancy(isBetween($params.getStart(), $params.getEnd(), startDate), isBetween($params.getStart(), $params.getEnd(), endDate)) from $roomOccupancies)
then
    System.out.println("THERE IS A ROOM");
    modify($checkRoomAvailability){setHotelRoom($room);}
end

rule "Hotel - Number of Views"
lock-on-active
when
  $event: HotelEvent(hotelEventType == HotelEventType.VIEW, $hotel: hotel)
  $h: Hotel(id == $hotel.getId())
//  accumulate(
//    $viewEvent: HotelEvent($hotel == hotel, hotelEventType == HotelEventType.VIEW) over window:time(5h),
//    $points: ( accumulate($v: $viewEvent; count($v) < 3), -1;
//               accumulate($v: $viewEvent; count($v) > 10), 1;
//               accumulate($v: $viewEvent; count($v) > 30), 5;
//               accumulate($v: $viewEvent; count($v) > 100), 10;
//               0 )
//  )
  $numberOfViews: Long() from accumulate(
      $v: HotelEvent($hotel == hotel, hotelEventType == HotelEventType.VIEW)
      over window: time(5h),
      count($v)
  )
then
    // TODO: numberOfViews -> points
  System.out.println("HOTEL VIEWED");
  modify($h){addPoints($numberOfViews)};
end

rule "Hotel - Number of Bookings"
lock-on-active
when
  $event: HotelEvent(hotelEventType == HotelEventType.RESERVATION, $hotel: hotel)
  $h: Hotel(id == $hotel.getId())
    $numberOfViews: Long() from accumulate(
        $v: HotelEvent($hotel == hotel, hotelEventType == HotelEventType.RESERVATION)
        over window: time(24h),
        count($v)
    )
//  accumulate(
//    HotelEvent($hotel == hotel, hotelEventType == HotelEventType.BOOKING) over window:time(24h) from $events: List(),
//    $points: ( $events.size() > 3 ? 1 :
//               $events.size() > 10 ? 5 :
//               $events.size() > 15 ? 10 :
//               0 )
//  )
then
  System.out.println("HOTEL BOOKED");
  modify($h){addPoints($numberOfViews)};
end

rule "Hotel - Number of Positive Reviews"
lock-on-active
when
  $event: HotelEvent(hotelEventType == HotelEventType.POSITIVE_REVIEW, $hotel: hotel)
  $h: Hotel(id == $hotel.getId())
  $numberOfViews: Long() from accumulate(
      $v: HotelEvent($hotel == hotel, hotelEventType == HotelEventType.POSITIVE_REVIEW)
      over window: time(24h),
      count($v)
  )
//  accumulate(
//    HotelEvent($hotel == hotel, hotelEventType == HotelEventType.POSITIVE_REVIEW) over window:time(1h) from $events: List(),
//    $points: ( $events.size() > 3 ? 1 :
//               $events.size() > 5 ? 5 :
//               $events.size() > 10 ? 10 :
//               0 )
//  )
then
  System.out.println("POSITIVE REVIEW");
  modify($h){addPoints($numberOfViews)};
end

rule "Hotel - Number of Negative Reviews"
lock-on-active
when
  $event: HotelEvent(hotelEventType == HotelEventType.NEGATIVE_REVIEW, $user: user, $hotel: hotel)
  $h: Hotel(id == $hotel.getId())
   $numberOfViews: Long() from accumulate(
        $v: HotelEvent($hotel == hotel, hotelEventType == HotelEventType.NEGATIVE_REVIEW)
        over window: time(24h),
        count($v)
    )
//  accumulate(
//    HotelEvent($hotel == hotel, hotelEventType == HotelEventType.NEGATIVE_REVIEW) over window:time(24h) from $events: List(),
//    $points: ( $events.size() > 3 ? -5 :
//               $events.size() > 10 ? -$negativeReviews :
//               0 )
//  )
then
  System.out.println("NEGATIVE REVIEW");
  modify($h){addPoints($numberOfViews)};
end

rule "Sort and Select Top 10 Hotels"
no-loop
when
    $event: ReloadPopularHotelsEvent()
    $hotels: List() from collect(Hotel(points > 0))
then
    $hotels.sort(Comparator.comparing(Hotel::getPoints).reversed());
    modify($event){setHotels($hotels);}
end

function boolean isBetween(Date min, Date max, Date d) {
    return d.after(min) && d.before(max);
}

function double holidayDiscount(int daysBeforeStay, boolean holidayPeriod) {
    if (daysBeforeStay >= 16 && daysBeforeStay <= 25) {
        if (holidayPeriod) {
            return 5.0;
        } else {
            return 10.0;
        }
    } else if (daysBeforeStay >= 6 && daysBeforeStay <= 15) {
        if (holidayPeriod) {
            return 10.0;
        } else {
            return 15.0;
        }
    } else if (daysBeforeStay <= 5) {
        if (holidayPeriod) {
            return 15.0;
        } else {
            return 20.0;
        }
    }
    return 0.0;
}

function boolean isHolidayPeriod(Date date) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("MM-dd");
    String formattedDate = dateFormat.format(date);
    String[] holidayPeriods = {
        "01-01", // New Year's Day
        "12-25", // Christmas
        "07-04", // Independence Day
        "10-31", // Halloween
        "11-11", // Veterans Day
    };

    for (String holiday : holidayPeriods) {
        if (formattedDate.equals(holiday)) {
            return true;
        }
    }
    return false;
}

function int calculateNumberOfNights(Date startD, Date endD) {
    LocalDate startDate = startD.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    LocalDate endDate = endD.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    long daysBetween = ChronoUnit.DAYS.between(startDate, endDate);
    return (int) daysBetween;
}
